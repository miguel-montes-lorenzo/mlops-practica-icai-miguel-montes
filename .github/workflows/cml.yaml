name: MLOps with CML

# on: [push, pull_request]
on: [push] #, pull_request]

jobs:
  train-and-report:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: DVC and Python setup
        uses: iterative/setup-dvc@v1

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Configure Git
        run: |
          git config --global user.email "TUEMAIL"
          git config --global user.name "TUUSUARIO"

      - name: Restore DVC Cache
        uses: actions/cache@v3
        with:
          path: ~/.cache/dvc
          key: dvc-cache-${{ hashFiles('dvc.yaml', 'dvc.lock') }}
          restore-keys: |
            dvc-cache-

      - name: Install DVC S3 plugin
        run: |
          python3 -m pip install --upgrade pip
          pip install "dvc[s3]"

      - name: DVC Pull
        env:
          DAGSHUB_API_KEY: ${{ secrets.DAGSHUB_API_KEY }}
          # Las credenciales de Dagshub son necesarias para acceder al almacenamiento remoto
        run: |
          dvc remote modify origin --local access_key_id $DAGSHUB_API_KEY
          dvc remote modify origin --local secret_access_key $DAGSHUB_API_KEY
          # dvc pull -r origin
          dvc pull -r origin --jobs 1


      - name: Install dependencies
        run: |
          python3 -m pip install --upgrade pip
          pip install pyyaml
          pip install -r requirements.txt

      - uses: iterative/setup-cml@v1

      - name: Run training script
        env:
          MLFLOW_TRACKING_USERNAME: ${{ secrets.DAGSHUB_USERNAME }}
          MLFLOW_TRACKING_PASSWORD: ${{ secrets.DAGSHUB_API_KEY }}
          MLFLOW_TRACKING_URI: ${{ secrets.MLFLOW_TRACKING_URI }}
        run: |
          # DVC repro ejecutará la etapa "train" y, por lo tanto, el script train.py.
          # dvc pull data/iris_dataset.csv
          dvc repro

  deploy-to-gke:
    needs: train-and-report
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      # --- in
      - name: DVC and Python setup
        uses: iterative/setup-dvc@v1

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install DVC S3 plugin
        run: |
          python3 -m pip install --upgrade pip
          pip install "dvc[s3]"

      - name: DVC Pull (model + data if needed)
        env:
          DAGSHUB_API_KEY: ${{ secrets.DAGSHUB_API_KEY }}
        run: |
          dvc remote modify origin --local access_key_id $DAGSHUB_API_KEY
          dvc remote modify origin --local secret_access_key $DAGSHUB_API_KEY
          dvc pull -r origin

      - name: Check model exists
        run: |
          ls -lah
          test -f model.pkl && echo "model.pkl OK" || (echo "model.pkl NO EXISTE" && exit 1)
      # --- out

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: '${{ secrets.GCP_SA_KEY }}'
      
      # --- in
      - name: Check active Google account
        run: |
          gcloud auth list
          gcloud config list account
      # --- out

      - name: Set up gcloud CLI and kubectl
        uses: google-github-actions/setup-gcloud@v2
        with:
          install_components: gke-gcloud-auth-plugin

      - name: Debug vars
        run: |
          echo "GKE_CLUSTER='${{ secrets.GKE_CLUSTER }}'"
          echo "GKE_ZONE='${{ secrets.GKE_ZONE }}'"
          echo "GCP_PROJECT_ID='${{ secrets.GCP_PROJECT_ID }}'"
          test -n "${{ secrets.GKE_ZONE }}" || (echo "GKE_ZONE está VACÍA" && exit 1)

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials \
            ${{ secrets.GKE_CLUSTER }} \
            --zone ${{ secrets.GKE_ZONE }} \
            --project ${{ secrets.GCP_PROJECT_ID }}

      # 1st implementation

      # - name: Configure Docker for GCR
      #   run: |
      #     gcloud auth configure-docker --quiet

      # - name: Build and Push API Docker Image
      #   run: |
      #     docker build -t gcr.io/${{ secrets.GCP_PROJECT_ID }}/mlops-api:latest .
      #     docker push gcr.io/${{ secrets.GCP_PROJECT_ID }}/mlops-api:latest

      # ---
      
      # 2nd implementation

      # - name: Configure Docker for GCR
      #   run: |
      #     gcloud auth configure-docker gcr.io --quiet

      # - name: Build and Push API Docker Image
      #   run: |
      #     IMAGE="gcr.io/${{ secrets.GCP_PROJECT_ID }}/mlops-api:latest"
      #     docker build -t "$IMAGE" .
      #     docker push "$IMAGE"

      # ---

      # 3rd implementation

      - name: Configure Docker to use GCR
        run: |
          gcloud auth configure-docker gcr.io --quiet

      # --- CONSTRUIR Y SUBIR IMAGEN DE LA API (mlops-api) ---
      # - name: Build and Push API Docker Image
      #   run: |
      #     docker build -t gcr.io/${{ secrets.GCP_PROJECT_ID }}/mlops-api:latest .
      #     docker push gcr.io/${{ secrets.GCP_PROJECT_ID }}/mlops-api:latest
      - name: Build and Push API Docker Image
        run: |
          IMAGE="gcr.io/${{ secrets.GCP_PROJECT_ID }}/mlops-api:latest"
          docker build -t "$IMAGE" .
          docker push "$IMAGE"

      # --- CONSTRUIR Y SUBIR IMAGEN DE LA WEB (mlops-web) ---
      # - name: Build and Push Web Docker Image
      #   run: |
      #     docker build -t gcr.io/${{ secrets.GCP_PROJECT_ID }}/mlops-web:latest -f Dockerfile.web .
      #     docker push gcr.io/${{ secrets.GCP_PROJECT_ID }}/mlops-web:latest
      - name: Build and Push Web Docker Image
        run: |
          IMAGE="gcr.io/${{ secrets.GCP_PROJECT_ID }}/mlops-web:latest"
          docker build -t "$IMAGE" -f Dockerfile.web .
          docker push "$IMAGE"

      # ----

      - name: Deploy API to GKE
        run: |
          # api deployment
          kubectl apply -f k8s/api-deployment.yaml
          kubectl apply -f k8s/api-service.yaml
          # web deployment
          kubectl apply -f k8s/web-deployment.yaml
          kubectl apply -f k8s/web-service.yaml
